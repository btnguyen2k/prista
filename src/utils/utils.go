/*
Package utils provides a utility/helper functions that can be used by the application.

@author Thanh Nguyen <btnguyen2k@gmail.com>
@since template-v0.4.r1
*/
package utils

import (
	"bytes"
	olaf2 "github.com/btnguyen2k/consu/olaf"
	"github.com/go-akka/configuration/hocon"
	"math/rand"
	"net"
	"strconv"
	"strings"
	"time"
)

// global variables
var (
	// Location should be initialized during application bootstrap
	Location *time.Location
)

func getMacAddr() string {
	interfaces, err := net.Interfaces()
	if err == nil {
		for _, i := range interfaces {
			if i.Flags&net.FlagUp != 0 && bytes.Compare(i.HardwareAddr, nil) != 0 {
				// Don't use random as we have a real address
				return i.HardwareAddr.String()
			}
		}
	}
	return ""
}

func getMacAddrAsLong() int64 {
	mac, _ := strconv.ParseInt(strings.Replace(getMacAddr(), ":", "", -1), 16, 64)
	return mac
}

var olaf = olaf2.NewOlaf(getMacAddrAsLong())

// UniqueId generates a unique id.
func UniqueId() string {
	return olaf.Id128Hex()
}

// UniqueIdSmall generates a unique id, shorter length than which is generated by UniqueId.
func UniqueIdSmall() string {
	return olaf.Id64Ascii()
}

const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

// RandomString generates a random string with specified length.
func RandomString(l int) string {
	b := make([]byte, l)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}

func UnwrapHocon(h interface{}) interface{} {
	switch h.(type) {
	case hocon.HoconValue:
		return unwrapHoconValue(h.(hocon.HoconValue))
	case *hocon.HoconValue:
		return unwrapHoconValue(*h.(*hocon.HoconValue))
	case hocon.HoconObject:
		return unwrapHoconObject(h.(hocon.HoconObject))
	case *hocon.HoconObject:
		return unwrapHoconObject(*h.(*hocon.HoconObject))
	case map[string]interface{}:
		return unwrapMap(h.(map[string]interface{}))
	case *map[string]interface{}:
		return unwrapMap(*h.(*map[string]interface{}))
	case []hocon.HoconValue:
		return unwrapSliceHoconValue(h.([]hocon.HoconValue))
	case *[]hocon.HoconValue:
		return unwrapSliceHoconValue(*h.(*[]hocon.HoconValue))
	case []*hocon.HoconValue:
		return unwrapSlicePHoconValue(h.([]*hocon.HoconValue))
	case *[]*hocon.HoconValue:
		return unwrapSlicePHoconValue(*h.(*[]*hocon.HoconValue))
	case []interface{}:
		return unwrapSlice(h.([]interface{}))
	case *[]interface{}:
		return unwrapSlice(*h.(*[]interface{}))
	}
	return h
}

func unwrapSliceHoconValue(h []hocon.HoconValue) []interface{} {
	result := make([]interface{}, 0)
	for _, v := range h {
		result = append(result, UnwrapHocon(v))
	}
	return result
}

func unwrapSlicePHoconValue(h []*hocon.HoconValue) []interface{} {
	result := make([]interface{}, 0)
	for _, v := range h {
		result = append(result, UnwrapHocon(v))
	}
	return result
}

func unwrapMap(h map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})
	for k, v := range h {
		result[k] = UnwrapHocon(v)
	}
	return result
}

func unwrapSlice(h []interface{}) []interface{} {
	result := make([]interface{}, 0)
	for _, v := range h {
		result = append(result, UnwrapHocon(v))
	}
	return result
}

func unwrapHoconValue(h hocon.HoconValue) interface{} {
	if h.IsString() {
		return h.GetString()
	}
	if h.IsObject() {
		return UnwrapHocon(h.GetObject())
	}
	if h.IsArray() {
		return UnwrapHocon(h.GetArray())
	}
	return nil
}

func unwrapHoconObject(h hocon.HoconObject) interface{} {
	return UnwrapHocon(h.Unwrapped())
}
